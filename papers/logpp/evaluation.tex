% !TeX root = Logpp.tex
Given the implementation of \projn from~\autoref{sec:implementation} we now shift 
to evaluating how well the resulting system meets the design goals outlined in~\autoref{sec:design}.\\

\noindent
For this evaluation we use four of microbenchmarks with $10$k iterations: 

\begin{lstlisting}[language=JavaScript,basicstyle=\scriptsize,numbers=none]
//Basic
log.info("hello world -- logger")
//String
log.info("hello %s", "world")
//Compound
log.info("hello %s %j %d", "world", { obj: true }, 4)
//Compute
log.info("hello at %j with %j %n -- %s", 
         new Date(), ["i", { f: i, g: "#" + i }], 
         i - 5, (i % 2 === 0 ? "ok" : "skip"))
\end{lstlisting}

\noindent
We also use a simple server based on the popular \emph{express}~\cite{} framework 
which provides a \emph{REST} API for querying data on the S\&P 500 companies.

All of the benchmarks are run on an Intel Xeon E5-1650 CPU with 6 cores at 3.50GHz, 32GB of RAM, and a SSD. 
The software stack is Windows 10 (17134) and Node v10.0.

\subsection{Microbenchmarks}
Our first evalaution is with current state of the art logging approaches in 
Node.js. These include the builtin \texttt{console} methods, the \texttt{debug}~\cite{debuglogger} 
module, the \texttt{bunyan}~\cite{bunyanlogger} logger, and the \texttt{pino}~\cite{pinologger} logger.

\begin{table}[t]  
    \centering
    \begin{tabular}{l | r r r r r | r }
    Program       & \bench{Basic}  & \bench{String}   & \bench{Compound}  & \bench{Compute} \\
    \hline
    Console       & $883$ms & $852$ms & $1064$ms & $986$ms \\
    Debug         & $202$ms & $200$ms & $282$ms  & $469$ms \\
    Bunyan        & $477$ms & $531$ms & $603$ms  & $920$ms \\
    Pino          & $188$ms & $190$ms & $296$ms  & $630$ms \\
    Log++         & $89$ms  & $93$ms  & $155$ms  & $304$ms \\
    \hline
    Speedup & $2.1$-$9.9\times$ & $2.0$-$9.2\times$ & $1.8$-$6.9\times$ & $2.1$-$3.2\times$ \\
    \end{tabular}
    \vspace{2mm}
    \caption{Timings for each logging framework on $10$k iterations with given format. 
    Speedup is the min-max speedup relative to the other logging frameworks.}
    \label{tab:microcompare}
\end{table}

The results in~\autoref{tab:microcompare} show the wide performance variation across logging 
frameworks (spanning nearly a factor of $10\times$). Accross all benchmarks \projn is consistently 
the fastest logger, by a factor of at least $1.8$-$2.1\times$, when compared to the best performing 
of the existing logging frameworks.

\subsection{Logging Optimization Impacts}
To understand how much each of our design choices and optimizations contributed to 
this performance we look at the performance impacts of specific features in \projn. 

\begin{table}[t]  
    \centering
    \begin{tabular}{l | r r r r r | r }
    Program       & \bench{Basic}  & \bench{String}   & \bench{Compound}  & \bench{Compute} \\
    \hline
    Enabled       & $883$ms & $852$ms & $1064$ms & $986$ms \\
    Disabled      & $883$ms & $852$ms & $1064$ms & $986$ms \\
    Sync-Lazy     & $202$ms & $200$ms & $282$ms  & $469$ms \\
    Sync-Strict   & $202$ms & $200$ms & $282$ms  & $469$ms \\
    Multi-Level   & $477$ms & $531$ms & $603$ms  & $920$ms \\
    \end{tabular}
    \vspace{2mm}
    \caption{ASDF}
    \label{tab:featureeval}
\end{table}

Lets do some microbencharks on logging and break down the impact of various 
implementation/design ideas...

enabled full

disabled

multi-level impact

expando impact

\begin{table}[t]  
    \centering
    \begin{tabular}{l | r r r r r | r }
    Program       & \bench{Host}  & \bench{App}   & \bench{Wallclock}  & \bench{Timestamp} \\
    \hline
    Explicit      & $883$ms & $852$ms & $1064$ms & $986$ms \\
    Expando       & $202$ms & $200$ms & $282$ms  & $469$ms \\
    \end{tabular}
    \vspace{2mm}
    \caption{ASDF}
    \label{tab:expando}
\end{table}

\subsection{Logging Performance}
Lets do some macro benchmarks on a couple of non-micro workloads to see the 
impact in practice...

No logging
----
Stat         Avg     Stdev   Max
Latency (ms) 0.14    0.55    38.43
Req/Sec      12011.1 2212.64 13170
Bytes/Sec    3.66 MB 678 kB  4.03 MB

132k requests in 11s, 40.4 MB read

console.log
----
Stat         Avg     Stdev   Max
Latency (ms) 1.18    0.83    48.53
Req/Sec      6038.3  1082.77 6668
Bytes/Sec    1.84 MB 328 kB  2.04 MB

60k requests in 10s, 18.5 MB read

pino         
----
Stat         Avg     Stdev  Max
Latency (ms) 0.89    0.7    39.69
Req/Sec      8133.3  1457.5 8861
Bytes/Sec    2.49 MB 441 kB 2.71 MB

81k requests in 10s, 24.9 MB read

Logpp detail 
----
Stat         Avg     Stdev   Max
Latency (ms) 0.67    0.8     42.78
Req/Sec      8645.1  1656.58 9784
Bytes/Sec    2.64 MB 503 kB  2.99 MB

86k requests in 10s, 26.4 MB read

logpp info   
----
Stat         Avg     Stdev   Max
Latency (ms) 0.58    0.77    43.77
Req/Sec      8958.55 1654.89 10075
Bytes/Sec    2.75 MB 508 kB  3.08 MB

99k requests in 11s, 30.1 MB read

\subsection{Logging Data Size}

study of simplified output log and reduction in storage/transport sizes -- 
e.g., save XXMB of traffic/storage per day kind of thing.

compression impact
